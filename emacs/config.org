#+TITLE: Emacs Config
#+AUTHOR: soham
#+OPTIONS: toc:t date:t

This is my Emacs configuration. Based on [[https://github.com/jamiecollinson/dotfiles/blob/master/config.org/][Jamie Collision's]] and [[https:github.com/DiegoVicen/my-emacs/blob/master/README.org][Diego Vicente's]]
configurations, with some additions from [[https:pragamaticemacs.com][Pragmatic Emacs]].

* Basic Setup
** Configure package sources

Add repositories from which Emacs will load packages. At present I am using the
MELPA repository exclusively. MELPA Stable might be a better choice for
stability,  but it does not have all the packages that I use.

#+BEGIN_SRC emacs-lisp
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   '("melpa" . "https://melpa.org/packages/") t))
#+END_SRC

*** TODO Check if MELPA Stable has all the required packages.

** Increase garbage collector threshold

The default garbage collection threshold is 800kB, increasing this to 10MB for
startup increases speed (from 11.0s -> 9.7s when I tested).

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 10000000)

;; Restore after startup
(add-hook 'after-init-hook
          (lambda ()
            (setq gc-cons-threshold 1000000)
            (message "gc-cons-threshold restored to %S"
                     gc-cons-threshold)))
#+END_SRC

** Configuration directory

Directory for all my configurations.

#+BEGIN_SRC emacs-lisp
(setq configuration-dir "~/dots/emacs/")
#+END_SRC

** Edit and reload config

These are keybindings to easily edit and reload this configuration file.

#+BEGIN_SRC emacs-lisp
(defun reload-emacs-configuration()
  "Reload the configuration"
  (interactive)
  (load "~/.emacs"))

(defun open-emacs-configuration ()
  "Open the configuration.org file in buffer"
  (interactive)
  (find-file (concat configuration-dir "config.org")))

(global-set-key (kbd "C-c R") 'reload-emacs-configuration)
(global-set-key (kbd "C-c I") 'open-emacs-configuration)
#+END_SRC

** Backups folder

I absolutely hate the =filename#= spamming that Emacs does. At the same time I
love that I can have a backup in case I accidentally powered off my computer
without saving the files I was working on. This setup centralises the backup
files created by Emacs.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
      backup-by-copying t    ; Don't delink hardlinks
      version-control t      ; Use version numbers on backups
      delete-old-versions t  ; Automatically delete excess backups
      kept-new-versions 20   ; how many of the newest versions to keep
      kept-old-versions 5    ; and how many of the old
      )
#+END_SRC

** Set custom settings to load in own file

This stops Emacs adding customised settings to =init.el=. I try to avoid using
customize anyway, preferring programmatic control of variables. Creating it as a
temporary file effectively disables it (i.e. any changes are session local).

#+BEGIN_SRC emacs-lisp
(setq custom-file (make-temp-file "emacs-custom"))
#+END_SRC

** Add custom packages to load path

By default Emacs only includes files directly under =user-emacs-directory=
(usually =~/.emacs.d/=), so we need to add any folders containing custom
packages. I put my scripts under =lisp= directory in my configuration directory
and symlink with =stow=.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat configuration-dir "lisp"))
#+END_SRC

** Shorter yes or no prompts

Single key strokes are probably better than triple key strokes.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable default startup screen

I have no particular use for the default startup screen. I prefer the dashboard
used by Spacemacs / Doom Emacs, which we will come to later. For now let us
disable the startup-screen. While we are at it also start the =scratch= buffer
in =org-mode= and disable the default =scratch= buffer message.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      initial-scratch-message ""
      initial-major-mode 'org-mode)
#+END_SRC

** Disable the bell

The bell is a absolute no-no.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Emacs abbreviations

I have not used Emacs abbreviations much, but seems like they can be
useful, probably when I am typing my thesis. Just in case let us fix some
choices for the abbreviations.

#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silent
      abbrev-file-name "~/.emacs.d/abbrev_defs")
#+END_SRC

** Tabs vs Spaces

Going to go with spaces on this one. I will also fix tab width to 2.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+END_SRC

** Fix scroll

Smoother scroll whether I am using the keyboard or the mouse (sometimes the
mouse can be useful).

#+BEGIN_SRC emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000
      mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil
      mouse-wheel-follow-mouse 't)
#+END_SRC

** Bootstrap use-package

I am using =use-package= to install all the other Emacs packages that I
use. There are quite a few excellent Emacs package managers on the market. But
this is the one I am used to, and I would rather just install the packages and
get to work that figure out how to use a different package manager. This
installs =use-package=, if it is not already installed.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

By default all packages should be installed from package manager as that's the
usual path. This is equivalent to setting =:ensure t= on each call to
=use-package=. To disable we just have to set =:ensure nil= (this is done
automatically for any packages using =:load-path= so shouldn't generally be
needed).

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

** Automatic package updates

No one wants to check for package updates manually, unless they are concerned
about breakages. I am not for the most part, so I will use =auto-package-update=.

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :config
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-hide-results t)
  (setq auto-package-update-prompt-before-update t)
  (auto-package-update-maybe))
#+END_SRC

** Benchmark startup

I want to check how much time Emacs takes to startup, so that I can optimize it
if required. There's a nifty package called =benchmark-init= that records
startup time by package. It only records things after it is initialised, so it
needs to be put as early in config as possible.

#+BEGIN_SRC emacs-lisp
(use-package benchmark-init
  :hook
  ;; To disable collection of benchmark data after init is done.
  (after-init . benchmark-init/deactivate)
  (after-init . (lambda () (message "loaded in %s" (emacs-init-time)))))
#+END_SRC

** Environment management

Since I usually use the Emacs GUI the =exec-path= variable is left empty at
startup. We need to load the contents of =$PATH= to the =exec-path= variable and
call it at start.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :demand t
  :config
  (setq exec-path-from-shell-variables
        '("PATH" "MANPATH" "DESKTOP_SESSION"))
  (exec-path-from-shell-initialize))
#+END_SRC

** Insert new line without breaking

Vim has this nifty shortcut =o=, which inserts a new line below the line in
which the cursor is. I do not want to go full =evil=, but I do like this one
feature of vim. To have the same behavior in Emacs, I found this custom
function that I bound to C-o.

#+BEGIN_SRC emacs-lisp
(defun insert-new-line-below ()
  "Add a new line below the current line"
  (interactive)
  (let ((oldpos (point)))
    (end-of-line)
    (newline-and-indent)))

(global-set-key (kbd "C-o") 'insert-new-line-below)
#+END_SRC

** Move buffers around

If we want to swap buffers location in frames, there’s no fast way to do it in
Emacs by default. To do it, a good option that I found is to use buffer-move
package, and use these key bindings.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :bind (("C-c w <up>"    . buf-move-up)
         ("C-c w <down>"  . buf-move-down)
         ("C-c w <left>"  . buf-move-left)
         ("C-c w <right>" . buf-move-right)))
#+END_SRC

** Redefining sentences

For some reason Emacs assumes that we end sentences with a period and /two/
whitespaces. I generally use a single whitespace after the period. To move in
sentences we need to redefine sentence endings for Emacs.

#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC

** Fill-column

I prefer code and text to respect the 80 characters per line limit, even though
sometimes, particularly with code, it is not possible at all.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

** Auto-fill comments

For our comments (only comments, not code) to be automatically filled in
programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** Delete selection

Emacs by default does not follow the contemporary behavior of allowing
highlighted text to be deleted. But that is whad I am more used to. So we will
activate the =delete-selection-mode=.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

** Scroll in the compilation buffer

Automatically scroll the compilation buffer as the output is printed.

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output t)
#+END_SRC

** Delete trailing whitespaces

I *never* want whitespace at the end of lines. Remove it on save.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Highlight the current line.

This highlights the line the cursor is on. Helps me to focus.

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
#+END_SRC

** Set the fringe as the background

In the GUI mode, each Emacs window has narrow fringes on the left and right
edges. This function allows to set the fringe color the same as the background,
which makes it look flatter and more minimalist.

#+BEGIN_SRC emacs-lisp
(defun set-fringe-as-background ()
  "Force the fringe to have the same color as the background"
  (set-face-attribute 'fringe nil
                      :foreground (face-foreground 'default)
                      :background (face-background 'default)))
#+END_SRC

* Graphical Interface
** Disable GUI defaults

I prefer a minimalistic looks which means that the GUI defaults have to take the
highway.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Fonts!!!

Who does not like a good font? My choice is Adobe's Source Code Pro.

#+BEGIN_SRC emacs-lisp
(set-frame-font "Source Code Pro 12" nil t)
#+END_SRC

** Setting the theme

=doom-themes= is an excellent collection of themes. I sometimes cycle through
them, using =counsel-load-theme= to load the themes. For now I will set
=doom-solarized-light= as the default theme.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (load-theme 'doom-solarized-light t))
#+END_SRC

** Icons!!!

=all-the-icons= has all the icons! So let us use it.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :after font-lock+)
#+END_SRC

** Modeline

I hardly use the mouse with Emacs, and I have disabled all default mouse
features. But I am going to make an exception for the =moody= + =minions=
alternative to the builtin modeline.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :config
  (setq minions-mode-line-lighter "[+]")
  (minions-mode))

(use-package moody
  :config
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)
  (setq-default x-underline-at-descent-line t
                column-number-mode t))
#+END_SRC

* Packages \ Tools
** Crux

A Collection of Ridiculously Useful eXtensions for Emacs. =crux= bundles a few
useful interactive commands to enhance your overall Emacs experience. I have the
following settings:
- =C-a= Move to the first non-whitespace character on a line, and then to
  between that and the beginning of the line
- =C-k= First kill to end of line, then kill the whole line
- =C-c o= Open the currently visited file with an external program
- =C-S-RET= Insert an empty line above the current line and indent it properly
- =S-RET= Insert an empty line and indent it properly
- =C-c n= Fix indentation in buffer and strip whitespace
- =C-c f= Open recently visited file
- =C-c D= Delete current file and buffer
- =C-c e= Eval a bit of Emacs Lisp code and replace it with its result
- =C-c d= Duplicate the current line (or region)
- =C-c TAB= Indent and copy region to clipboard

#+BEGIN_SRC emacs-lisp
(use-package crux
  :demand
  :bind
  (("C-a" . crux-move-beginning-of-line)
   ("C-k" . crux-smart-kill-line)
   ("C-c o" . crux-open-with)
   ("C-S-<return>" . crux-smart-open-line-above)
   ("S-<return>" . crux-smart-open-line)
   ("C-c n" . crux-cleanup-buffer-or-region)
   ("C-c f" . crux-recentf-find-file)
   ("C-c D" . crux-delete-file-and-buffer)
   ("C-c e" . crux-eval-and-replace)
   ("C-c d" . crux-duplicate-current-line-or-region)
   ("C-c <tab>" . crux-indent-rigidly-and-copy-to-clipboard)))
#+END_SRC

** Dash

Modern list api for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dash)
(use-package dash-functional)
#+END_SRC
** Dashboard

This is the dashboard that is used in Spacemacs / Doom Emacs. I find it quite
useful, though sometimes it does not update the recent files as early as I
prefer.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :config
  (dashboard-setup-startup-hook))
#+END_SRC

** Dired enhancements

Emac's =dired= is probably the best file manager that I have used. A close
second is =ranger=. Here are some packages that add some of the functionalities
of =ranger= that I particularly like to =dired=.

#+BEGIN_SRC emacs-lisp
  (use-package dired-hacks-utils)
  (use-package dired-ranger
    :after (dash)
    :bind (:map dired-mode-map
                ("W" . dired-ranger-copy)
                ("X" . dired-ranger-move)
                ("Y" . dired-ranger-paste)))
  (use-package dired-filter
    :after (dash)
    :bind (:map dired-mode-map
                ("F" . dired-filter-map)))
  (use-package dired-avfs)
  (use-package dired-rainbow)
  (use-package dired-collapse)
  (use-package dired-narrow
    :bind (:map dired-mode-map
                ("/" . dired-narrow)))
  (use-package dired-subtree
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)
                ("<backtab>" . dired-subtree-cycle)))
#+END_SRC

There is an =all-the-icons= package for =dired=. So let us add that too!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

Default switches for =dired=.

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lath --group-directories-first")
#+END_SRC

** Command completion

=smart M-x= suggests =M-x= commands based on recency and frequency. I don't tend
to use it directly but =counsel= uses it to order suggestions.

#+BEGIN_SRC emacs-lisp
(use-package smex)
#+END_SRC

=ivy= is a generic completion framework which uses the minibuffer. Turning on
=ivy-mode= enables replacement of lots of built in =ido=
functionality. =ivy-rich= adds a friendlier interface to =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish ivy-mode
  :config
  (ivy-mode t)
  (setq ivy-display-style 'fancy))

(use-package ivy-rich
  :after ivy
  :config
  ;; Disable TRAMP buffers extended information to prevent slowdown
  (setq ivy-rich-parse-remote-buffer nil)
  :init (ivy-rich-mode 1))

(use-package all-the-icons-ivy-rich
  :after ivy-rich
  :init (all-the-icons-ivy-rich-mode 1))

(setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
#+END_SRC

By default =ivy= starts filters with =^=. I don't normally want that and can
easily type it manually when I do.

#+BEGIN_SRC emacs-lisp
(setq ivy-initial-inputs-alist nil)
#+END_SRC

=counsel= is a collection of =ivy= enhanced versions of common Emacs commands. I
haven't bound much as =ivy-mode= takes care of most things.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("M-x" . counsel-M-x)))
#+END_SRC

=swiper= is an =ivy= enhanced version of isearch.

#+BEGIN_SRC emacs-lisp
(use-package swiper)
(global-set-key (kbd "C-s") 'counsel-grep-or-swiper)
;; (global-set-key (kbd "M-s") 'isearch-forward)
;; (global-set-key (kbd "M-r") 'isearch-backward)
#+END_SRC

=hydra= presents menus for =ivy= commands.

#+BEGIN_SRC emacs-lisp
(use-package ivy-hydra)
#+END_SRC

** Suggest next key

Suggest next keys based on currently entered key combination.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :hook
  (after-init . which-key-mode))
#+END_SRC

** Better undo

=undo-tree= visualises undo history as a tree for easy navigation.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :defer 5
  :diminish global-undo-tree-mode
  :config
  (global-undo-tree-mode 1))
#+END_SRC

** Navigation

One of the most important features of an advanced editor is quick text
navigation. =avy= lets us jump to any character or line quickly.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind (("M-s" . avy-goto-word-1)))
#+END_SRC

=ace-window= lets us navigate between windows in the same way as =avy=. Once
activated it has useful sub-modes like =x= to switch into window deletion mode.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :config
  (global-set-key (kbd "C-x o") 'ace-window)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC

** Easier selection

=expand-region= expands the region around the cursor semantically depending on
mode. Hard to describe but a killer feature.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+END_SRC

** Emoji support.

This is useful when working with html.

#+BEGIN_SRC emacs-lisp
(use-package emojify)
#+END_SRC

** Git

Magit is an awesome interface to git. Summon it with `C-x g`.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config (setq magit-branch-read-upstream-first 'fallback)
  :bind ("C-x g" . magit-status))
#+END_SRC

Display line changes in gutter based on git history. Enable it everywhere.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :config
  (global-git-gutter-mode 't)
  :diminish git-gutter-mode)
#+END_SRC

TimeMachine lets us step through the history of a file as recorded in git.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine)
#+END_SRC

** Project management

Still not sure how to make best uses of =projectile=, but everyone and their cow
praises =projectile=.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (projectile-mode 1))
#+END_SRC

Tell projectile to integrate with =ivy= for completion.

#+BEGIN_SRC emacs-lisp
(setq projectile-completion-system 'ivy)
#+END_SRC

Add some extra completion options via integration with =counsel=. In particular
this enables =C-c p SPC= for smart buffer / file search, and =C-c p s s= for
search via =ag=.

There is no function for projectile-grep, but we could use =counsel-git-grep=
which is similar. Should I bind that to =C-c p s g=?

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :hook
  (after-init . counsel-projectile-mode))
#+END_SRC

** Syntax and spelling

=Flycheck= is a general syntax highlighting framework which other packages hook
into. It's an improvment on the builtin =flymake=. Setup is pretty simple - we
just enable globally and turn on a custom eslint function.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  (add-to-list 'flycheck-checkers 'proselint)
  (setq-default flycheck-highlighting-mode 'lines)
  ;; Define fringe indicator / warning levels
  (define-fringe-bitmap 'flycheck-fringe-bitmap-ball
    (vector #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00011100
            #b00111110
            #b00111110
            #b00111110
            #b00011100
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000))
  (flycheck-define-error-level 'error
    :severity 2
    :overlay-category 'flycheck-error-overlay
    :fringe-bitmap 'flycheck-fringe-bitmap-ball
    :fringe-face 'flycheck-fringe-error)
  (flycheck-define-error-level 'warning
    :severity 1
    :overlay-category 'flycheck-warning-overlay
    :fringe-bitmap 'flycheck-fringe-bitmap-ball
    :fringe-face 'flycheck-fringe-warning)
  (flycheck-define-error-level 'info
    :severity 0
    :overlay-category 'flycheck-info-overlay
    :fringe-bitmap 'flycheck-fringe-bitmap-ball
    :fringe-face 'flycheck-fringe-info)
  :hook
  (after-init . global-flycheck-mode))
#+END_SRC

=Flyspell= is a builtin spelling checker. I prefer it to be activated for
=text-mode= and for comments in =prog-mode=.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

** Autocomplete

=Company= is a pretty good autocompletion system.

#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish
  :demand t
  :config
  (setq company-show-numbers t
        company-tooltips-align-annotations t)
  :hook
  (prog-mode . company-mode)
  (latex-mode . company-mode)
  (org-mode . company-mode))
#+END_SRC

I don't want suggestions from open files / buffers to be automatically
lowercased as these are often camelcase function names.

#+BEGIN_SRC emacs-lisp
(setq company-dabbrev-downcase nil)
#+END_SRC

** Parens and delimiters

When programming I like my editor to try to help me with keeping parentheses
balanced.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish smartparens-mode
  :config
  (require 'smartparens-config)
  :hook
  (prog-mode . smartparens-mode)
  (org-mode . smartparens-mode))
#+END_SRC

Highlight parens etc. for improved readability.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Highlighted color strings

I prefer strings which represent colours to be highlighted, and I only want this
in programming modes, and I don't want colour names to be highlighted
(=x-colors=).

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :config
  (setq rainbow-x-colors nil)
  :hook
  (prog-mode . rainbow-mode))
#+END_SRC

** Indentations

=agressive-indent-mode= is more reliable than =electric-indent-mode= at keeping
my code always indented.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent)
#+END_SRC

** Jump to source

Individual language packages often support IDE features like jump to source, but
=dumb-jump= attempts to support many languages by simple searching. It's quite
effective even with dynamic libraries like JS and Python.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :diminish dumb-jump-mode
  :config
  (setq dumb-jump-selector 'ivy
        dumb-jump-aggressive nil)
  :bind (("C-M-g" . dumb-jump-go)
         ("C-M-p" . dumb-jump-back)
         ("C-M-q" . dumb-jump-quick-look)))
#+END_SRC

** Snippets

Unlike autocomplete which suggests words / symbols, snippets are pre-prepared
templates which you fill in. I'm using a community library =yasnippet-snippets=
with *lots* of ready made options, and have my own directory of custom snippets
I've added. Type the shortcut and press =TAB= to complete, or =M-/= to
autosuggest a snippet.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :config
  (add-to-list 'yas-snippet-dirs (concat user-emacs-directory "snippets"))
  (yas-global-mode)
  (global-set-key (kbd "M-/") 'company-yasnippet))
(use-package yasnippet-snippets)
#+END_SRC

** Universal / Exuberant Ctags

Tags based completion for large projects. So far I have found this to be
more reliable than =lsp-mode= and =eglot= for IDE-like completion. [[https://github.com/universal-ctags/ctags][Universal
Ctags]] or some other ctag implementation needs to be installed. Additionally =GNU
Find= can also be used as a backend. Another alternative is to use =GNU Global=
with the [[https://github.com/universal-ctags/ctags][Universal Ctags]] backend, and =ggtags= or =counsel-gtags=. For now this
setup seems to work, so I will stick with it.

#+BEGIN_SRC emacs-lisp
(use-package counsel-etags
  :bind (("C-]" . counsel-etags-find-tag-at-point))
  :init
  (add-hook 'prog-mode-hook
            (lambda ()
              (add-hook 'after-save-hook
                        'counsel-etags-virtual-update-tags 'append 'local)))
  :config
  (setq counsel-etags-update-interval 60)
  (push "build" counsel-etags-ignore-directories))
#+END_SRC

To generate the tags, we need to execute =ctags -Re= in the working directory
and then =M-x visit-tags-table=.

** Terminal

=sane-term= restores some sanity to =ansi-term= to provide something close to a
proper shell in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package sane-term
  :config
  (defun set-up-sane-term ()
    "Fix yanking and prepare for sane-term-mode."
    (setq-local global-hl-line-mode nil)
    (define-key
      term-raw-map
      (kbd "C-y")
      (lambda ()
        (interactive)
        (term-line-mode)
        (yank)
        (term-char-mode))))
  :hook (term-mode . set-up-sane-term)
  :bind (("C-c t" . sane-term)
         ("C-c T" . sane-term-create)
         ("C-c C-j" . sane-term-mode-toggle)))
#+END_SRC

** PDF reader

=pdf-tools= is better at this than =doc-view=. There are some helpful
tweaks on [[http://pragmaticemacs.com/emacs/even-more-pdf-tools-tweaks/][Pragmatic Emacs]].

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-width)
  ;; Automatically annotate highlights.
  (setq pdf-annot-activate-created-annotations t)
  ;; Use isearch instead of swiper.
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  :hook
  (pdf-view . pdf-links-minor-mode)
  ;; Turn of cua so copy works.
  (pdf-view . (lambda () (cua-mode 0))))
#+END_SRC

** Djvu reader

Not as good as =pdf-tools= but gets the job done. My preferred =djvu= reader is
=zathura= though.

#+BEGIN_SRC emacs-lisp
(use-package djvu)
#+END_SRC

* Programming Modes
** Markdown

Not technically a progmramming mode but wth. Markdown support isn't built into
Emacs, add it with =markdown-mode=.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC

** C/C++

Google C++ style.

#+BEGIN_SRC emacs-lisp
(require 'google-c-style)
(c-add-style "google" google-c-style)
#+END_SRC

My preferred style for home projects.

#+BEGIN_SRC emacs-lisp
(c-add-style "modified-bsd"
             '("bsd"
               (c-basic-offset . 2)
               (c-offsets-alist
                (arglist-intro . ++)
                (arglist-close . +))))
#+END_SRC

=clang-format+= to automatically format C/C++ code. This will enable automatic
formatting of C/C++ files in source trees with a =.clang-format= (or
=_clang-format=) file.

#+BEGIN_SRC emacs-lisp
(use-package clang-format+
  :hook
  (c-mode-common . clang-format+-mode))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :hook
  (python-mode . anaconda-mode)
  (python-mode . anaconda-eldoc-mode)
  :bind
  ("C-c C-d" . anaconda-mode-show-doc)
  :config
  (setq python-shell-interpreter "ipython"))

(use-package company-anaconda
  :config
  (add-to-list 'company-backends 'company-anaconda)
  :hook
  (python-mode . company-mode))
#+END_SRC

=IPython= as python interpreter.

#+BEGIN_SRC emacs-lisp
(when (executable-find "ipython")
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "--simple-prompt -i"))

(with-eval-after-load 'python
  (defun python-shell-completion-native-try ()
    "Return non-nil if can trigger native completion."
    (let ((python-shell-completion-native-enable t)
          (python-shell-completion-native-output-timeout
           python-shell-completion-native-try-output-timeout))
      (python-shell-completion-native-get-completions
       (get-buffer-process (current-buffer))
       nil "_"))))
#+END_SRC

** R

Emacs Speaks Statistics for R.

#+BEGIN_SRC emacs-lisp
(use-package ess)
(use-package ess-R-data-view)
#+END_SRC

#+RESULTS:

** LaTeX

AUCTeX is probably the best TeX editing system. On the fence about CDLaTeX, not
including it for the time being.

#+BEGIN_SRC emacs-lisp
(use-package tex
  :demand t
  :ensure auctex
  :config
  (setq-default TeX-engine 'luatex)
  (setq-default TeX-PDF-mode t)
  (setq-default TeX-master nil)
  (setq TeX-parse-self t)
  (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
  (setq reftex-plug-into-AUCTeX t)
  (setq reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource"))
  (setq reftex-default-bibliography '("~/Documents/research/bibliography/references.bib"))
  (setq reftex-use-external-file-finders t)
  (setq reftex-external-file-finders
        '(("tex" . "kpsewhich -format=.tex %f")
          ("bib" . "kpsewhich -format=.bib %f")))
  (setq reftex-insert-label-flags '("s" "sft" "e"))
  (setq TeX-electric-sub-and-superscrip t)
  (setq TeX-electric-math (cons "\\(" "\\)"))
  (setq LaTeX-electric-left-right-brace t)
  :hook
  ((LaTeX-mode . visual-line-mode)
   (LaTeX-mode . turn-on-auto-fill)
   (LaTeX-mode . flyspell-mode)
   (LaTeX-mode . LaTeX-math-mode)
   (LaTeX-mode . turn-on-reftex)
   (TeX-after-compilation-finished-functions
    . TeX-revert-document-buffer)))

(use-package auctex-latexmk
  :hook
  (LaTeX-mode . auctex-latexmk-setup))
#+END_SRC

=company-mode= backends for LaTeX; the unicode symbols are also useful in
=org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package company-math
  :config
  (add-to-list 'company-backends 'company-math-symbols-latex)
  (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

=ivy-bibtex= for easy searching of references.

#+BEGIN_SRC emacs-lisp
(use-package ivy-bibtex
  :config
  (setq ivy-re-builders-alist
      '((ivy-bibtex . ivy--regex-ignore-order)
        (t . ivy--regex-plus)))
  (setq ivy-bibtex-default-action #'ivy-bibtex-insert-citation)
  (setq bibtex-completion-bibliography
        '("~/Documents/research/bibliography/references.bib"))
  :bind
  ("C-c b" . ivy-bibtex-with-local-bibliography))
#+END_SRC

=Ebib= for managing references.

#+BEGIN_SRC emacs-lisp
(use-package ebib
  :config
  ;; Point it to our database
  (setq ebib-file-search-dirs '("~/Documents/research/"))
  (setq ebib-preload-bib-files '("~/Documents/research/bibliography/references.bib"))

  ;; `ebib' uses `bibtex.el' to auto-generate keys for us
  (setq bibtex-autokey-year-length 4
        bibtex-autokey-name-year-separator "-"
        bibtex-autokey-year-title-separator "-"
        bibtex-autokey-titleword-separator "-"
        bibtex-autokey-titleword-length nil
        bibtex-autokey-titlewords 2
        bibtex-autokey-titlewords-stretch 1)

  ;; Make ebib window easier to deal with
  (setq ebib-index-window-size 25))
#+END_SRC

* Org mode

My life in plain text.

** General settings

Default directory for =org-mode= and define some =org-mode= variables.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
(setq org-directory "~/org/")
(setq org-special-ctrl-a/e t)
(setq org-default-notes-file (concat org-directory "notes.org"))
(setq org-src-window-setup 'current-window)
;; Prevent demoting heading also shifting text inside sections.
(setq org-adapt-indentation nil)
;; Allow alphabetical bullets.
(setq org-list-allow-alphabetical t)
#+END_SRC

** Agenda and capture

Keybindings for =org-agenda= and =org-capture=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c a") 'org-agenda)
(global-set-key (kbd "C-c c") 'org-capture)
(global-set-key (kbd "C-c l") 'org-store-link)
#+END_SRC

Default agenda file.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list (concat org-directory "todo.org")))
#+END_SRC

TODO state keywords and color settings. This will also save timestamps when
completing tasks.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d!)" "DROP(x!)"))
      org-log-into-drawer t)
(setq org-todo-keyword-faces
      (quote (("TODO" . org-warning)
              ("STARTED" . "green")
              ("DONE" . (:foreground "blue" :weight bold))
              ("DROP" . "magenta"))))
#+END_SRC

TODO priority range from =A= to =C= with =A= being the highest and the default.

#+BEGIN_SRC emacs-lisp
(setq org-highest-priority ?A)
(setq org-lowest-priority ?C)
(setq org-default-priority ?A)

;; Colors for priorities.
(setq org-priority-faces '((?A . (:foreground "#F0DFAF" :weight bold))
                           (?B . (:foreground "LightSteelBlue"))
                           (?C . (:foreground "OliveDrab"))))
#+END_SRC

TODO capture template.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("t" "todo" entry (file+headline "~/org/todo.org" "Tasks")
         "* TODO [#A] %?")))
#+END_SRC

** Appearance

Improve the display of bullet points.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :config
  (setq org-bullets-bullet-list '("∙"))
  :hook
  (org-bullets . org-mode))
#+END_SRC

Fontify whole line for headings.

#+BEGIN_SRC emacs-lisp
(setq org-fontify-whole-heading-line t)
#+END_SRC

=auto-fill-mode= for =org-mode= too.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
#+END_SRC

=htmlize= for code blocks.

#+BEGIN_SRC emacs-lisp
(require 'htmlize)
#+END_SRC

** LaTeX with org-mode

If AUCTeX is the best TeX editing system then =org-mode= is definitely a close
second. Depending on what kind of document I am writing, I might prefer one over
the other. For =org-mode= to LaTeX export I prefer certain defaults.

=latexmk= the LaTeX exporter.

#+BEGIN_SRC emacs-lisp
(setq org-latex-pdf-process
      '("latexmk -pdf -quiet -shell-escape -bibtex -f -pdf %f"))
#+END_SRC

=lstlisting= for source environments.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-packages-alist '("" "listingsutf8" nil))
(setq org-latex-listings 'listings)
(setq org-latex-listings-options '(("breaklines" "true")))
#+END_SRC

Preserve indentations.

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

This setting will make subscripts (x_{subscript}) and superscripts
(x^{superscript}) appear in org in a AUCTeX fashion.

#+BEGIN_SRC emacs-lisp
(setq-default org-pretty-entities t)
#+END_SRC

D&D with =org-mode= and LaTeX.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat configuration-dir "lisp/" "emacs-org-dnd"))
(require 'ox-dnd)
#+END_SRC

Revtex 4.2 for writing papers.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("revtex4-2"
               "
\\documentclass[aps,prc,preprint,citeautoscript,showkeys,floatfix]{revtex4-2}
\\usepackage{braket}
\\usepackage{mathtools}
\\usepackage{diffcoeff}
\\usepackage{bm}
\\usepackage{hyperref}
\\usepackage{natbib}
\\usepackage{graphicx}
[NO-DEFAULT-PACKAGES]
[PACKAGES]
[EXTRAS]
"
               ("\\section{%s}" . "\\section{%s}")
               ("\\subsection{%s}" . "\\subsection{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection{%s}")
               ("\\paragraph{%s}" . "\\paragraph{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph{%s}")))
#+END_SRC

=zotxt= for references.

#+BEGIN_SRC emacs-lisp
(use-package zotxt)
#+END_SRC

** Jupyter

#+BEGIN_SRC emacs-lisp
(use-package jupyter
  :defer t)
#+END_SRC

** Spell checking

Add spell checking by enabling flyspell in its buffers. The configuration for
flyspell is above.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

** Reveal.js export

=org-reveal= for presentations using =reveal.js=. =org-re-reveal= can also be
used here. I tend to jump between the two; using =org-re-reveal= when
=org-reveal= breaks down. But =org-reveal= project has recently become active
again, so hopefully less break downs.

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :config
  (setq org-reveal-root "https://www.jsdelivr.com/package/npm/reveal.js"))
#+END_SRC

** Display inline images

A small piece of elisp extracted from The Joy of Programming to properly display
inline images in org.

#+BEGIN_SRC emacs-lisp
(defun my/fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(add-hook 'org-babel-after-execute-hook 'my/fix-inline-images)
(setq-default org-image-actual-width 620)
#+END_SRC

** My website publishing configuration

#+BEGIN_SRC emacs-lisp
(require 'ox-publish)

;; From http://www.i3s.unice.fr/~malapert/emacs_orgmode.html#org4230632.
(setq org-html-coding-system 'utf-8-unix)
(setq org-html-validation-link nil)
(setf org-html-mathjax-options
      '((path "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")
        (scale "100")
        (align "center")
        (indent "2em")
        (mathml nil)))
(setf org-html-mathjax-template
      "<script type=\"text/javascript\" src=\"%PATH\"></script>")

(setq org-publish-project-alist
      '(("islr-notes"
         :base-directory "~/Documents/islr/"
         :base-extension "org"
         :publishing-directory "~/Documents/islr/docs/"
         :recursive t
         :htmlized-source t
         :publishing-function org-html-publish-to-html
         :auto-preamble t
         :auto-sitemap t
         :sitemap-filename "sitemap.org"
         :sitemap-title "Sitemap"
         :with-creator nil
         :with-email nil
         :with-author nil
         :html-head-include-default-style nil
         :html-head-include-scripts nil
         :html-validation-link nil
         :html-link-home "index.html"
         :html-link-up "sitemap.html")
        ("islr-images"
         :base-directory "~/Documents/islr/img"
         :base-extension "png\\|jpg\\|gif\\|pdf"
         :publishing-directory "~/Documents/islr/docs/img/"
         :recursive t
         :exclude "ISLR.pdf"
         :publishing-function org-publish-attachment)
        ("islr-static"
         :base-directory "~/Documents/islr/static/"
         :base-extension "css\\|otf"
         :publishing-directory "~/Documents/islr/docs/static/"
         :recursive t
         :publishing-function org-publish-attachment)
        ("islr-tangle"
         :base-directory "~/Documents/islr/"
         :publishing-directory "~/Documents/islr/python/"
         :recursive t
         :publishing-function org-babel-tangle-publish)
        ("islr" :components("islr-notes" "islr-images" "islr-static" "islr-tangle"))))
#+END_SRC

** Planning file per project

I like the idea of having a file in the root of each project called
planning.org, in which I can put all the tasks, ideas, and other research I
perform about a project. In case I add TODO entries, meetings, or other
artifacts, I want them to appear in the agenda. For that reason, this functions
checks for possible planning files existing in my projects.

#+BEGIN_SRC emacs-lisp
(defun get-my-planning-files ()
  "Get a list of existing planning files per project."
  (let ((candidates (map 'list
                         (lambda (x) (concat x "planning.org"))
                         (projectile-relevant-known-projects))))
    (remove-if-not 'file-exists-p candidates)))

(defun update-planning-files ()
  "Update the org-agenda-files variable with the planning files per project."
  (interactive)
  (dolist (new-org-file (get-my-planning-files))
    (add-to-list 'org-agenda-files new-org-file)))

;; For some reason, the list seem to be overwritten during init
(add-hook 'after-init-hook 'update-planning-files)
#+END_SRC

** Babel

Org-babel can be used for literate programming, executing source code within
org-mode.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t)
   (latex . t)
   (ditaa . t)
   (C . t)
   (R . t)
   (python . t)
   (jupyter . t)))
#+END_SRC

Syntax highlighting and tabbing in source blocks.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively 't)
(setq org-src-tab-acts-natively t)
#+END_SRC

Custom source blocks

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("E" "#+BEGIN_SRC emacs-lisp \n  ?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist
             '("p" "#+BEGIN_SRC python \n  ?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist
             '("R" "#+BEGIN_SRC R \n  ?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist
             '("jp" "#+BEGIN_SRC jupyter-python \n  ?\n#+END_SRC"))
#+END_SRC

** Reload org-mode

For some reason it gives an error otherwise.

#+BEGIN_SRC emacs-lisp
(org-reload)
#+END_SRC
